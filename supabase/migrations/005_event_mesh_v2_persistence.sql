-- Event Mesh V2: DocumentableEvent Persistence Layer
-- Month 5: Universal Orchestration Layer
-- Added: November 24, 2025
-- Description: Adds database persistence for events to enable self-documentation and debugging

-- Event History Table
-- Stores all DocumentableEvents with user intent and context
-- Used for "explain what happened" narratives and knowledge graph
CREATE TABLE event_history (
  id TEXT PRIMARY KEY, -- UUID generated by client
  event_name TEXT NOT NULL,
  source TEXT NOT NULL,
  timestamp BIGINT NOT NULL, -- Unix timestamp in milliseconds
  payload JSONB NOT NULL,

  -- V2 DocumentableEvent fields
  should_document BOOLEAN DEFAULT false,
  user_intent JSONB, -- { problemSolved, painPoint, goal, expectedOutcome, impactMetric }
  context JSONB, -- { decision, outcome, relatedEvents[], category }
  metadata JSONB, -- { userId, sessionId, environment }

  -- Audit fields
  created_at TIMESTAMPTZ DEFAULT NOW(),

  -- Optional user association (NULL for anonymous/system events)
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Indexes for efficient queries
CREATE INDEX idx_event_history_event_name ON event_history(event_name);
CREATE INDEX idx_event_history_source ON event_history(source);
CREATE INDEX idx_event_history_timestamp ON event_history(timestamp DESC);
CREATE INDEX idx_event_history_user_id ON event_history(user_id) WHERE user_id IS NOT NULL;
CREATE INDEX idx_event_history_should_document ON event_history(should_document) WHERE should_document = true;

-- Index for graph traversal (find events by related event IDs)
-- Uses GIN index on JSONB array for fast containment checks
CREATE INDEX idx_event_history_related_events
  ON event_history USING gin ((context->'relatedEvents'))
  WHERE context->'relatedEvents' IS NOT NULL;

-- Index for metadata queries (userId, sessionId, environment)
CREATE INDEX idx_event_history_metadata_user
  ON event_history USING gin ((metadata->'userId'));
CREATE INDEX idx_event_history_metadata_session
  ON event_history USING gin ((metadata->'sessionId'));

-- Enable Row Level Security
ALTER TABLE event_history ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Users can view/create their own events + anonymous events
CREATE POLICY "Users can view their own events"
  ON event_history
  FOR SELECT
  USING (
    user_id = auth.uid()
    OR user_id IS NULL -- Allow viewing anonymous events (dev mode)
  );

CREATE POLICY "Users can insert their own events"
  ON event_history
  FOR INSERT
  WITH CHECK (
    user_id = auth.uid()
    OR user_id IS NULL -- Allow creating anonymous events (dev mode)
  );

-- Note: No UPDATE or DELETE policies - events are immutable after creation
-- Except for outcome updates, which we'll handle via a special function

-- Function to update event outcomes asynchronously
-- This is the ONLY way to modify events after creation
CREATE OR REPLACE FUNCTION update_event_outcome(
  event_id TEXT,
  outcome_text TEXT,
  impact_metric TEXT DEFAULT NULL
)
RETURNS void AS $$
BEGIN
  UPDATE event_history
  SET context = jsonb_set(
    COALESCE(context, '{}'::jsonb),
    '{outcome}',
    to_jsonb(outcome_text)
  )
  WHERE id = event_id
    AND (user_id = auth.uid() OR user_id IS NULL); -- RLS check

  -- Optionally update impact metric
  IF impact_metric IS NOT NULL THEN
    UPDATE event_history
    SET user_intent = jsonb_set(
      COALESCE(user_intent, '{}'::jsonb),
      '{impactMetric}',
      to_jsonb(impact_metric)
    )
    WHERE id = event_id
      AND (user_id = auth.uid() OR user_id IS NULL);
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Narrative Context Table
-- Stores additional context for events that needs rich text/long-form content
-- Separated from event_history to keep that table fast and lean
CREATE TABLE narrative_context (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  event_id TEXT NOT NULL REFERENCES event_history(id) ON DELETE CASCADE,

  -- Rich context fields
  long_description TEXT, -- Extended user explanation (beyond userIntent fields)
  screenshots TEXT[], -- URLs to screenshots/images
  code_snippets JSONB, -- { language: "typescript", code: "..." }
  related_docs TEXT[], -- URLs to related documentation

  -- AI-generated content
  ai_narrative TEXT, -- Generated narrative from buildNarrative()
  ai_summary TEXT, -- Short summary (1-2 sentences)
  ai_tags TEXT[], -- Auto-extracted tags for categorization

  -- Audit fields
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(event_id) -- One narrative context per event
);

-- Indexes for narrative context queries
CREATE INDEX idx_narrative_context_event_id ON narrative_context(event_id);
CREATE INDEX idx_narrative_context_ai_tags ON narrative_context USING gin (ai_tags);

-- Enable Row Level Security
ALTER TABLE narrative_context ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Follow event_history permissions
CREATE POLICY "Users can view narrative context for their events"
  ON narrative_context
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM event_history
      WHERE event_history.id = narrative_context.event_id
        AND (event_history.user_id = auth.uid() OR event_history.user_id IS NULL)
    )
  );

CREATE POLICY "Users can insert narrative context for their events"
  ON narrative_context
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM event_history
      WHERE event_history.id = narrative_context.event_id
        AND (event_history.user_id = auth.uid() OR event_history.user_id IS NULL)
    )
  );

CREATE POLICY "Users can update narrative context for their events"
  ON narrative_context
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM event_history
      WHERE event_history.id = narrative_context.event_id
        AND (event_history.user_id = auth.uid() OR event_history.user_id IS NULL)
    )
  );

-- Auto-update timestamp trigger
CREATE TRIGGER update_narrative_context_updated_at
  BEFORE UPDATE ON narrative_context
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); -- Reuse function from 002_backend_proxy.sql

-- Cleanup old events (keep last 90 days for documentable events, 7 days for others)
-- Run this as a periodic maintenance task via cron
CREATE OR REPLACE FUNCTION cleanup_old_event_history()
RETURNS void AS $$
BEGIN
  -- Delete non-documentable events older than 7 days
  DELETE FROM event_history
  WHERE should_document = false
    AND timestamp < EXTRACT(EPOCH FROM NOW() - INTERVAL '7 days') * 1000;

  -- Delete documentable events older than 90 days
  DELETE FROM event_history
  WHERE should_document = true
    AND timestamp < EXTRACT(EPOCH FROM NOW() - INTERVAL '90 days') * 1000;

  -- Narrative context will auto-delete via CASCADE
END;
$$ LANGUAGE plpgsql;

-- Comments for documentation
COMMENT ON TABLE event_history IS 'Event Mesh V2 persistence layer. Stores all DocumentableEvents with user intent and context for self-documentation and debugging.';
COMMENT ON COLUMN event_history.should_document IS 'Flag indicating this event should be included in AI-generated narratives. Auto-set to true for: widget.created, provider.connected, automation.triggered.';
COMMENT ON COLUMN event_history.user_intent IS 'Captures why the user took this action. Schema: { problemSolved, painPoint, goal, expectedOutcome, impactMetric }';
COMMENT ON COLUMN event_history.context IS 'Contextual information about this event. Schema: { decision, outcome, relatedEvents[], category }';
COMMENT ON COLUMN event_history.metadata IS 'Technical metadata for debugging. Schema: { userId, sessionId, environment }';
COMMENT ON TABLE narrative_context IS 'Extended context for events requiring rich text, screenshots, or AI-generated narratives. One-to-one with event_history.';
COMMENT ON FUNCTION update_event_outcome IS 'Updates the outcome field of an event asynchronously. This is the ONLY way to modify events after creation (events are immutable except for outcomes).';
